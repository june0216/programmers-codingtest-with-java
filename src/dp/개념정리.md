# DP

- 완전 탐색의 일종
- 완전 탐색의 문제점 = 중복된 과정 발생 → 비효율적

## 메모이제이션

- DP는 메모이제이션 기법을 사용
- 한 번 풀었던 부분 문제에 대한 답을 저장해 놓았다가 해당 부분 문제를 다시 풀 일이 생기면 재사용한다.
- 재귀 구현에 메모리제이션을 적용하는 과정
    - 1) 제시된 범위에 따라 메모이제이션 배열 선언과 초기화

      ```java
      private static final long[] mem = new long[101];
      Arrays.fill(mem, -1); // 정답이 될 수 없는 값으로 배열을 채움 
      ```

    - 2) 재귀 종료 조건에 메모이제이션 조건 추가
        - 풀어본 문제를 다시 풀지 못하게 하기 위해 조건 추가

      ```java
      if(mem[n] != -1) return mem[n]; // 계산 여부 조건 
      if(n == 0 || n == 1) return n; // 재귀 함수 종료 조건 
      ```

    - 부문 문제에 대한 답을 구한 후 메모이제이션 배열에 기록
        - 문제를 풀고 그 답을 기록해야한다.

            ```java
            return mem[n] = fibonacci(n-1) + fibonacci(n-2);
            ```

- 재귀 호출 횟수 177 → 19으로 크게 감소

### DP의 조건

- 중복되는 부분 문제가 많이 발생하는지 확인하고 DP 적용
    - 중복되는 부분문제가 없이 메모이제이션을 사용하는 것은 효율적이지 않다.
- 적용 방법
    - 1) 상태 (부분 문제) 정의하기
    - 2) 종료 조건 찾기
    - 3) 점화식 세우기
    - 4) 재귀로 구현하기
    - 5) 메모이제이션 적용하기
- 재귀 호출이 깊어지면 StackOverflowError 발생 가능
    - ex) 10,000부터 0까지 재귀 호출을 한다면 f(0)까지 종료되지 않고 재귀 호출을 하게 되어 깊어진다는 문제점이 있다.
    - ⇒ 작은 부분 문제부터 해결하자!
        - 이전에 이미 해결한 작은 부분 문제이기 때문에 최대 한 번의 재귀만 수행하게 된다. (재귀가 더 깊이 들어가지 않고 바로 종료 된다)

### 순차 누적으로 구현해보기

- DP를 반드시 재귀로 구현해야하는 것은 아님

  ⇒ 반복문을 이용한 **순차 누적**으로도 메모이제이션을 이용한 동적 프로그래밍을 구현할 수 있다.

    - 큰 부분 문제를 살펴보고 이를 풀기 위해 작은 문제를 살펴보았던 재귀와 반대로 순차 누적은 작은 부분 문제를 먼저 해결해나간다.
    - 작은 항부터 순회하며 다른 항들에 영향을 미치도록 구현해준다.
        - ex) f(n)을 해결하기 위해 f(n-1)과 f(n-2)가 필요하다
        - f(n)은 f(n+1)과 f(n+2)에 영향을 미친다는 것을 의미한다.

        ```java
        private static long iterativeFibonacci(int n) {
        	long[] mem = new long[n+1];
        	mem[0] = 0;
        	mem[1] = 1;
        	
        	for(int i = 0; i <= n-1; i++){
        		mem[i+1] += mem[i];
        		if(i+2 < mem.length){
        				mem[i+2] += mem[i];
        		}
        	}
        	return mem[n];
        }
        ```

        - 순차 누적에서는 메모이제이션 배열에 값을 순차적으로 쌓아 가므로 유효하지 않은 값으로 초기화할 필요가 없다. 그 대신 값이 누적될 수 있도록 0으로 초기화하고, 재귀 호출에서 종료 조건에 해당하는 첫 항을 미리 넣어주면 된다.