# 시간복잡도란?

- 코드의 실행시간이 어떤 요인으로 결정되는지 나타내는 시간과 입력 데이터의 함수 관계

## 2.1.1 빅오 표기법

- 알고리즘이 겪을 수 있는 최악의 경우에 걸리는 시간과 입력 간의 상관관계
- 입력 크기 N → 이에 비례하는 시간이 걸린다면 O(N)으로 표기

## 2.1.2 시간 복잡도 그래프

| 알고리즘 | 시간복잡도 |
| --- | --- |
| 이진탐색 | O(logN) |
| 선형탐색 | O(N) |
| 정렬 | O(N logN) |
| 조합 | O(2^N) |
| 순열 | O(N!) |

### O(NlogN)

일반화해서 길이가 N인 임의의 배열에 대해서 높이를 구하면 $2^x$=N를 만족하는 x을 찾아야 한다. 앞선 과정과 동일하게 양변에 2인 log를 취해 높이 x을 구하면 다음과 같은 식이 나온다. $x=logN$

즉, 단계의 높이 x는 배열의 길이 N에 의해 결정된다.

나아가 각 단계에서 정렬에 필요한 총 반복 횟수는 N이기에 전체 시간 복잡도는 높이 * 반복 횟수인  $O(NlogN)$이다.

예를 들어, 길이가 8인 배열이 있다고 가정해 보겠습니다. 이 배열을 병합 정렬을 사용하여 정렬한다고 했을 때, 분할 과정은 다음과 같이 진행됩니다:

1. 배열을 반으로 쪼갭니다: 길이가 8인 배열 -> 두 개의 길이가 4인 배열
2. 다시 반으로 쪼갭니다: 길이가 4인 배열 -> 네 개의 길이가 2인 배열
3. 마지막으로 한 번 더 쪼갭니다: 길이가 2인 배열 -> 여덟 개의 길이가 1인 배열

이제 이 쪼개진 배열들을 다시 합치며 정렬하는 과정이 시작됩니다. 이 과정에서 '높이'는 이 분할 단계의 수를 나타냅니다. 위의 예에서는 3단계의 분할이 있었으므로 높이는 3입니다.


## 입력 데이터 개수별 사용가능한 시간복잡도 알고리즘

- 최악의 경우를 시간 복잡도에 대입해보았을 때 1억이 넘지 않는다면 실행시간이 1초보다 빠른 충분히 효율적인 코드일 가능성이 높다.
    - 예시
        - N값이 1만이라고 가정한다면 시간복잡도 O(N logN) 일때 13만으로 계산된다.

          하지만 O(N^2)일 때, 1억이 된다.


### 문제 풀이 고려 순서

1) 문제 확인

2) 풀이 고안

3) 효율성 검증

3-1) 효율성 검증이 실패한다면 다시 풀이를 고안

4) 풀이 작성

5) 제출

## 시간복잡도 줄이는 법

### 제한시간이 1초일 때 유추 가능한 시간 복잡도와 알고리즘

| N | 유추 가능한 시간 복잡도  | 유추 가능한 알고리즘 |
| --- | --- | --- |
| 10 | O(N!) | 순열 |
| 20 | O(2^N) | 조합 |
| 1,000 | O(N^3), O(N^3 logN) | 완전 탐색, 이진 탐색 |
| 10,000~ | O(N logN)  | 정렬, 이진탐색 |