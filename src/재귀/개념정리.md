# 재귀란?

- 재귀는 메서드 호출을 이용한 방법으로, 하나의 메서드 내에서 자기 자신을 호출하도록 하여 반복적인 개념을 구현하는 것
- 하나의 재귀 호출은 **하나의 부분 문제를 해결**한다.
- 부분 문제를 푸는 재귀 호출에서 → 또 다른 부분 문제를 푸는 재귀 호출을 수행하며
    - 이렇게 호출된 **부분 문제들에 대한 답이 모여** 상위 호출의 답을 구성한다.
    - 모두 같은 메서드를 사용하기 때문에 부분 문제가 풀어야 하는 입력부만 다를 뿐 실제 푸는 로직은 동일

### for 문에서 벗어나기

- 반복문으로는 해결되지 않을 때도 있다.
    - 1) 여러 원소에 대한 조합이 필요한 경우
        - 2개 원소에 대한 조합 → 2중 for 문으로 구현

      ```java
      for(int i = 0; i < arr.length; i++){
              for(int j = 0; j < arr.length; j++){
                      //arr[i] arr[j]의 조합
              }
      }
      ```

        - 이렇게 2개의 조합이 아니라 3개, 4개, 5개, … **여러 개의 조합을 보고 싶을 때**는 3중 for문 , 4중 for문 , 5중 for문 .. 이렇게 늘어나야할 것이다.
    - 2) 조합해야 하는 원소가 문제에서 주어지는 변수일 때는 반복문을 작성할 수 없다.

### 재귀의 최대 범위와 한계점 기억하기

- 재귀 호출은 반복 작업을 구현하는 것이기 때문에 **재귀의 호출 횟수**가 **시간 복잡도에 직접적으로 영향**을 끼친다.
    - ⇒ 재귀호출을 구현할 때 1) 재귀 호출이 얼마나 수행되는지 2) 한 번 호출했을 때 어떤 작업을 하는지 고려해야 한다.
- **재귀 호출의 깊이**( = 재귀 호출이 얼마나 연쇄적으로 일어나는지) 고려해야 한다.
    - 재귀 호출을 하면 호출된 메서드에서 사용할 변수들은 메모리에 추가 할당
        - → 재귀 호출이 종료되어 더 이상 참조하지 않게 되었을 때 자동으로 메모리에서 할당이 해제 된다.
    - 중간에 종료되지 않고 너무 깊게 들어가버리면 변수들이 메모리를 모두 할당해서 stackOverflowError 예외가 발생한다. ⇒ 이러한 예외를 발생시키지 않으려면 재귀 호출의 깊이를 10,000 이하로 유지하기

# 재귀 정의하기

### 1) 상태 정의하기

- 재귀 == 부분 문제를 해결해 나가는 풀이 방법
- ⇒ 부분 문제는 각각 하나의 명확한 문제를 나타내어 하나의 답을 낼 수 있어야 한다.
    - 답을 내는 데 입력되는 변수들이 필요하고 이렇게 답을 결정하는 변수들을 “상태”라고 한다.
    - 부분 문제는 하나의 상태에 대한 답을 찾는 문제가 된다.
- 예시
    - (x, y)


### 2) 종료 조건

- 재귀 == 하나의 문제를 부분 문제들로 나누거나 부분 문제의 답을 이용하여 원본 문제의 답을 찾아야 풀 수 있다.
- 부분 문제는 상태에 대한 답을 찾는 것이므로 부분 문제가 나타내는 상태는 재귀가 진행될수록 점점 작아져 결국 이어지는 부분 문제 없이 즉시 답이 나와야 한다.
- 종료 조건 == 이렇게 이어지는 부분 문제 없이 **즉시 나오는 상태를 검사**하여 답을 반환할 수 있도록 하는 것
- 상태가 작아진다 == 종료 조건에 도달할 수 있도록 부분 문제로 상태가 변해가는 것

### 3) 점회식

- 상태와 종료 조건을 정의한 후에는 가장 큰 상태가 어떤 과정을 거쳐 가장 작은 상태인 종료 조건에 도달하는지 정의해야한다.
- 부분 문제는 같은 규칙으로 **더 작은 부분 문제로 진행**되어야 한다.
- ⇒ 상태 또한 하나의 규칙으로 더 작은 상태로 전이되어야 한다.
- 점화식 == 상태를 전이시키는 규칙

## 코드로 작성하기

- 하나의 부분 문제 == 하나의 메서드
- 상태 → 메서드의 입력부

    ```java
    private int power(int n, int m){
    }
    ```

- 종료 조건 작성하기

    ```java
    private int power(int n, int m){
    		if(m == 0) return 1;
    		if(n == 0) return 1;
    		if(n == 1) return 1;
    }
    ```

- 점화식 구현하기
    - 하나의 부분 문제를 더 작은 상태를 나타내는 부분 문제를 이용하여 푸는 규칙

    ```java
    private int power(int n, int m){
    		if(m == 0) return 1;
    		if(n == 0) return 1;
    		if(n == 1) return 1;
    		
    		return n * power(n, m-1);
    }
    ```